<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>킹콩 기린 점프 게임 - 정글 테마</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(to bottom, #d4f2a5 0%, #f0f9c2 45%, #4a7c4a 100%);
    font-family: sans-serif;
  }
  canvas {
    display: block;
    margin: 200px auto 0 auto; /* 게임 화면 아래로 이동 */
    background: transparent;
  }
  #score {
    position: absolute;
    top: 260px;
    left: 20px;
    font-size: 28px;
    font-weight: bold;
    color: #fff;
    text-shadow: 1px 1px 3px #000;
  }
  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 52px;
    color: red;
    display: none;
    text-align: center;
    text-shadow: 2px 2px 6px #000;
  }
  #gameTitle {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 40px;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 5px #000;
  }
  #logo {
  position: absolute;
  top: 2px;
  right: 24px;
  height: 160px; /* 높이 키우기 */
  /* 필요하면 width도 지정 가능 */
  /* width: auto; */
}
</style>
</head>
<body>

<canvas id="gameCanvas" width="1000" height="500"></canvas>

<div id="gameTitle">킹콩 기린 점프 게임</div>
<img id="logo" src="로고_바른에듀.png" alt="로고">
<div id="score">점수: 0</div>
<div id="gameOver">게임 오버</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const CANVAS_WIDTH = canvas.width;
const CANVAS_HEIGHT = canvas.height;

const dinoImg = new Image();
dinoImg.src = 'dino.png';

let score = 0;
let gameOver = false;
let gameSpeed = 8;
let frame = 0;
let speedIncrementedAt = 0;

const dino = {
  x: 80,
  y: 380,
  width: 120,  // 크기 더 크게
  height: 120, // 크기 더 크게
  dy: 0,
  gravity: 1,
  jumpPower: -18,
  onGround: true,
  draw() {
    if(dinoImg.complete) ctx.drawImage(dinoImg, this.x, this.y, this.width, this.height);
    else { ctx.fillStyle = '#654321'; ctx.fillRect(this.x, this.y, this.width, this.height); }
  },
  update() {
    this.y += this.dy;
    if (this.y + this.height < 400) { this.dy += this.gravity; this.onGround = false; }
    else { this.dy = 0; this.y = 400 - this.height; this.onGround = true; }
    this.draw();
  },
  jump() { if(this.onGround) this.dy = this.jumpPower; }
};

let obstacles = [];
function spawnObstacle() {
  const typeRand = Math.random();
  let type, obs;
  if(typeRand < 0.5) type = 'tree';
  else if(typeRand < 0.8) type = 'vine';
  else type = 'rock';

  obs = {
    x: CANVAS_WIDTH,
    y: type === 'tree' ? 370 : type === 'vine' ? 350 : 390,
    width: type === 'vine' ? 30 : 60,
    height: type === 'vine' ? 90 : 60,
    type: type,
    draw() {
      switch(this.type){
        case 'tree':
          ctx.fillStyle = '#2e8b57';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = '#0b6623';
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y, this.width, 0, Math.PI, true);
          ctx.fill();
          break;
        case 'vine':
          ctx.fillStyle = '#228b22';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          break;
        case 'rock':
          ctx.fillStyle = '#555';
          ctx.beginPath();
          ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI*2);
          ctx.fill();
          break;
      }
    },
    update() { this.x -= gameSpeed; this.draw(); }
  };
  obstacles.push(obs);
}

let clouds = [];
function spawnCloud() {
  const cloud = { x: CANVAS_WIDTH + Math.random() * 300, y: 60 + Math.random() * 80, width: 120, height: 60,
    draw() { ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.beginPath(); ctx.ellipse(this.x,this.y,this.width/2,this.height/2,0,0,Math.PI*2); ctx.fill(); },
    update() { this.x -= gameSpeed/2; this.draw(); }
  };
  clouds.push(cloud);
}

function drawGround(){
  ctx.fillStyle = '#654321';
  ctx.fillRect(0, 400, CANVAS_WIDTH, 100);
  ctx.fillStyle = '#3b7a57';
  ctx.fillRect(0, 405, CANVAS_WIDTH, 10);
}

function checkCollision(rect1, rect2){
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.y + rect1.height > rect2.y;
}

function animate(){
  ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);

  clouds.forEach(cl => cl.update());
  if(frame % 250 === 0) spawnCloud();

  obstacles.forEach((obs, index) => {
    obs.update();
    if(checkCollision(dino, obs)) endGame();
    if(obs.x + obs.width < 0) {
      obstacles.splice(index, 1);
      score++;
      document.getElementById('score').textContent = '점수: ' + score;

      // 점수 10점 단위 속도 증가
      if(score % 10 === 0 && score !== speedIncrementedAt){
        gameSpeed += 1.5;
        speedIncrementedAt = score;
      }
    }
  });

  if(frame % 120 === 0) spawnObstacle();

  drawGround();
  dino.update();

  if(!gameOver){
    frame++;
    requestAnimationFrame(animate);
  }
}

function endGame(){
  gameOver = true;
  document.getElementById('gameOver').style.display = 'block';
}

function resetGame(){
  obstacles = [];
  clouds = [];
  score = 0;
  frame = 0;
  gameSpeed = 8;
  speedIncrementedAt = 0;
  gameOver = false;
  document.getElementById('score').textContent = '점수: 0';
  document.getElementById('gameOver').style.display = 'none';
  dino.y = 380;
  animate();
}

function jumpHandler() {
  if(gameOver) resetGame();
  else dino.jump();
}

document.addEventListener('keydown', (e)=>{ if(e.code === 'Space') jumpHandler(); });
document.addEventListener('click', jumpHandler);

animate();
</script>

</body>
</html>
